# Общее описание файлов для запуска Django-приложения в Docker

Ниже приведены файлы, необходимые для упаковки и автоматического запуска Django-приложения с базой данных PostgreSQL, а также подробное объяснение каждого файла, комментарии к коду и порядок их исполнения.

---

## Файлы проекта

1. **create_admin.py** – скрипт для автоматического создания суперпользователя (админа) в Django.
2. **Dockerfile** – инструкции по сборке Docker-образа для Django-приложения.
3. **entrypoint.sh** – скрипт запуска (entrypoint), который выполняет ожидание готовности базы, миграции, загрузку фикстур, создание суперпользователя и запуск сервера.
4. **wait-for-db.sh** – утилита, которая ждёт, пока PostgreSQL станет доступным.
5. **docker-compose.yml** – файл для оркестрации контейнеров (Django и PostgreSQL).
6. **.env** – файл с переменными окружения (настройками Django, базы данных, почты и т.д.).

---

## 1. create_admin.py

Этот скрипт автоматически создаёт суперпользователя, если его ещё нет. Он настраивает Django (за счёт установки переменной `DJANGO_SETTINGS_MODULE`) и затем импортирует необходимые модули для создания пользователя.

```python
#!/usr/bin/env python
import os
# Устанавливаем переменную окружения, чтобы Django знало, где искать настройки
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'itg.settings')

import django
django.setup()  # Инициализируем Django для работы с моделями

from django.contrib.auth import get_user_model
User = get_user_model()

# Получаем данные для суперпользователя из переменных окружения или используем значения по умолчанию
username = os.environ.get('DJANGO_SUPERUSER_USERNAME', 'admin')
email = os.environ.get('DJANGO_SUPERUSER_EMAIL', 'admin@example.com')
password = os.environ.get('DJANGO_SUPERUSER_PASSWORD', 'adminpass')

# Проверяем, существует ли суперпользователь с заданным именем и создаем его, если нет
if not User.objects.filter(username=username).exists():
    print("Creating superuser...")
    User.objects.create_superuser(username=username, email=email, password=password)
else:
    print("Superuser already exists.")
```

**Ключевые моменты:**
- **Shebang:** `#!/usr/bin/env python` гарантирует, что скрипт будет запущен интерпретатором Python.
- **DJANGO_SETTINGS_MODULE:** Обеспечивает, что настройки Django будут загружены.
- **django.setup():** Инициализирует окружение Django.
- Суперпользователь создаётся только при его отсутствии.

---

## 2. Dockerfile

Dockerfile определяет, как будет собран Docker-образ для вашего Django-приложения. В нём устанавливаются системные зависимости, Python-зависимости, копируется код проекта и настраиваются права на выполнение скриптов.

```dockerfile
FROM python:3.10-slim

# Обновляем список пакетов и устанавливаем netcat-openbsd для утилиты nc, которая используется в wait-for-db.sh
RUN apt-get update && apt-get install -y netcat-openbsd && rm -rf /var/lib/apt/lists/*

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Копируем файл зависимостей и устанавливаем их
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Копируем весь проект в контейнер, включая скрипты wait-for-db.sh, entrypoint.sh и create_admin.py
COPY . .

# Делаем скрипты исполняемыми
RUN chmod +x /app/wait-for-db.sh && chmod +x /app/entrypoint.sh

# Открываем порт 8000 для работы Django
EXPOSE 8000

# Запускаем entrypoint-скрипт, который выполняет ожидание базы, миграции, загрузку фикстур, создание суперпользователя и запуск сервера
CMD ["sh", "-c", "/app/entrypoint.sh"]
```

**Ключевые моменты:**
- **Установка netcat-openbsd:** Необходим для выполнения команды `nc` в скрипте wait-for-db.sh.
- **COPY . .:** Копирует все файлы проекта в контейнер.
- **chmod +x:** Делает скрипты исполняемыми.
- **EXPOSE 8000:** Документирует, что приложение будет работать на порту 8000.
- **CMD:** Определяет команду, которая запускается при старте контейнера (через entrypoint.sh).

---

## 3. entrypoint.sh

Этот скрипт выполняется при запуске контейнера Django. Он:
1. Ждет, пока база данных станет доступной.
2. Выполняет миграции.
3. Загружает фикстуру данных.
4. Запускает скрипт создания суперпользователя.
5. Запускает сервер Django.

```sh
#!/bin/sh
set -e  # Останавливаем выполнение при ошибке

# Ждем, пока база данных не станет доступной (передаем имя сервиса "db" и порт 5432)
 /app/wait-for-db.sh db 5432

# Применяем миграции
python manage.py migrate

# Загружаем фикстуру (articles_4.json)
python manage.py loaddata articles_4.json

# Создаем суперпользователя, если его нет (выполняется через Python-скрипт)
python /app/create_admin.py

# Запускаем сервер Django, слушающий на всех интерфейсах
python manage.py runserver 0.0.0.0:8000
```

**Ключевые моменты:**
- **set -e:** Скрипт завершится, если любая команда завершится с ошибкой.
- **wait-for-db.sh:** Позволяет удостовериться, что PostgreSQL готов принимать соединения, прежде чем переходить к миграциям и загрузке данных.
- **Последовательное выполнение:** После ожидания базы выполняются миграции, загрузка фикстур, создание суперпользователя и запуск сервера.

---

## 4. wait-for-db.sh

Этот скрипт предназначен для проверки доступности сервера базы данных (PostgreSQL) через утилиту netcat (`nc`). Он периодически проверяет, доступен ли указанный хост и порт, и только после этого продолжает выполнение.

```sh
#!/bin/sh
# Останавливаем выполнение скрипта при возникновении ошибки
set -e

# Считываем первый аргумент скрипта в переменную 'host' (адрес базы данных)
host="$1"
# Считываем второй аргумент скрипта в переменную 'port' (порт базы данных)
port="$2"
# Сдвигаем аргументы, чтобы оставшиеся стали командой для выполнения после ожидания
shift 2

# Цикл: пока утилита nc не сможет подключиться к host:port, ждем 2 секунды и повторяем попытку
until nc -z "$host" "$port"; do
    echo "Waiting for PostgreSQL at $host:$port..."
    sleep 2
done

# Когда соединение установлено, выводим сообщение и выполняем оставшуюся команду
echo "PostgreSQL is up - executing command"
exec "$@"
```

**Ключевые моменты:**
- **nc -z:** Проверяет, открыт ли указанный порт.
- **until:** Цикл, который повторяется до тех пор, пока соединение не будет установлено.
- **exec "$@":** После успешного подключения выполняет команду, переданную скрипту (в нашем случае, команда в entrypoint.sh).

---

## 5. docker-compose.yml

Файл `docker-compose.yml` объединяет контейнеры для базы данных и Django-приложения, а также задаёт переменные окружения, тома и зависимости между сервисами.

```yaml
version: "3.8"

services:
  db:
    image: postgres:14
    container_name: django_db
    environment:
      POSTGRES_DB: ${PG_NAME}
      POSTGRES_USER: ${PG_USER}
      POSTGRES_PASSWORD: ${PG_PASSWORD}
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  web:
    build: .
    container_name: django_app
    # Запускаем entrypoint.sh, который выполняет ожидание БД, миграции, загрузку фикстур и создание суперпользователя
    command: sh -c "/app/entrypoint.sh"
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    env_file:
      - .env
    environment:
      # Переопределяем PG_HOST, чтобы Django подключался к контейнеру db
      PG_HOST: db
    depends_on:
      - db

volumes:
  pgdata:
```

**Ключевые моменты:**
- **services:**  
  - **db:**  
    - Использует образ PostgreSQL.
    - Переменные окружения берутся из файла .env (с префиксом PG_), позволяя задавать имя базы, пользователя и пароль.
    - Именованный том `pgdata` используется для сохранения данных базы.
    - Проброс порта "5432:5432" обеспечивает доступ к базе как изнутри, так и извне.
  - **web:**  
    - Собирается из текущей директории (директива build: .).
    - Использует entrypoint-скрипт (`/app/entrypoint.sh`), который автоматически выполняет ожидание базы, миграции, загрузку фикстур и создание суперпользователя.
    - Монтирует текущую директорию в контейнер для удобства разработки.
    - Использует файл .env для передачи переменных окружения.
    - Переопределяет PG_HOST на `db`, чтобы Django знал, что база находится в сервисе с именем `db`.
    - Зависимость `depends_on` гарантирует, что контейнер с базой запускается до Django.
- **volumes:**  
  Определяет именованный том `pgdata`, который используется для хранения данных PostgreSQL.

---

## Порядок запуска

1. **Сборка образа:**  
   Dockerfile используется для сборки образа приложения, копирования всех файлов и установки зависимостей.
2. **Запуск контейнеров:**  
   Команда `docker-compose up --build` запускает сервисы, указанные в docker-compose.yml:
   - Сначала поднимается контейнер базы данных `db`, который инициализирует кластер PostgreSQL и сохраняет данные в томе `pgdata`.
   - Затем запускается контейнер `web` (Django-приложение).
3. **EntryPoint (entrypoint.sh) в контейнере web:**  
   - Скрипт `wait-for-db.sh` ждёт, пока база не станет доступной (использует утилиту `nc`).
   - После успешного подключения выполняются миграции и загружается фикстура (articles_4.json).
   - Запускается скрипт `create_admin.py` для создания суперпользователя (если его нет).
   - Наконец, запускается сервер Django (runserver).

---

## Решение ошибки в allauth

Если при регистрации или входе возникает ошибка типа:
```
DoesNotExist at /accounts/login/ … No exception message supplied
```
и ошибка возникает в модуле allauth (например, при вызове `{% provider_login_url provider.id %}`), это значит, что:
- **SocialApp не настроен:**  
  В админке Django в разделе **Social Applications** отсутствует объект для соответствующего провайдера.
  
**Как исправить:**
1. Если вы планируете использовать социальный вход, зайдите в админку Django и создайте объект SocialApp для нужного провайдера (например, Google, Facebook и т.д.). Заполните поля Client ID и Secret, затем привяжите приложение к нужному сайту.
2. Если вы не планируете использовать социальный вход, можно отключить вывод кнопок соц. входа в шаблонах или настроить allauth так, чтобы они не вызывались.

---

## Итог

- **create_admin.py** автоматически создаёт суперпользователя.
- **Dockerfile** определяет среду для Django-приложения, устанавливает netcat для ожидания БД, копирует код и настраивает запуск через entrypoint.sh.
- **entrypoint.sh** последовательно ждёт доступности PostgreSQL, выполняет миграции, загружает фикстуру, создает суперпользователя и запускает сервер.
- **wait-for-db.sh** проверяет доступность базы данных с помощью утилиты nc.
- **docker-compose.yml** объединяет контейнеры для базы данных и Django, передавая переменные окружения (включая переопределение PG_HOST на db) и задавая зависимости.
- Если возникает ошибка в allauth, необходимо настроить SocialApp в админке или отключить соц. вход.

Такой набор файлов обеспечивает автоматическое развертывание и запуск Django-приложения с базой данных, а также решает типичные проблемы, связанные с ожиданием готовности БД и созданием суперпользователя.